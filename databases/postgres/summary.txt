
Data types

Text
Numeric
Boolean

date
uuid
enum
monetary
geometric
network address
xml
array

JSON : stores exact text, preserves key ordering

JSONB : does not preserve order of keys, does not keep duplicates (only last).
order of keys is lost to hashes

http://pgeoghegan.blogspot.in/2014/03/what-i-think-of-jsonb.html

You can create new type as composite, enum, range, base

https://www.compose.io/articles/is-postgresql-your-next-json-database/


-----------------------------
Indexing

https://www.compose.io/articles/what-postgresql-has-over-other-open-source-sql-databases-part-ii/
==============
B-tree 

==============
Hash


=============

BRIN Block Range Index
break up large table into ranges based on column to be indexed
==============


GIN  : composite data types
column must be tsvector type

 GIN consists of a B-tree index with one entry for every distinct key, 
 and a list of rows that have that value attached to each entry. The 
 “list of rows” is stored efficiently when there are a lot of rows, 
 but if there is only one row per value, ie. every row is unique, 
 it degenerates into an old-fashioned B-tree.

Insert or update of one row can cause many inserts into GIN
GIN inserts new tuples into temporary unsorted list
and then does Bulk insert
Searches must scan the pending entries

GIN supports partial match queries

GIN cannot handle null keys

JSON queries
1) can check if one json is contained inside another
2) path 
3) array has item

GIN operator classes specified during index creation
1) jsonb_path_ops 

jsonb_path_ops creates index items only for each value in the data. 

each jsonb_path_ops index item is a hash of the value and the key(s)
leading to it; for example to index {"foo": {"bar": "baz"}}, a single index item
would be created incorporating all three of foo, bar, and baz into the hash
value. Thus a containment query looking for this structure would result in an
extremely specific index search; but there is no way at all to find out whether
foo appears as a key. 

2) (default) jsonb_ops

jsonb_ops creates independent index items for each key and value 

jsonb_ops index would create three index items representing foo, bar, and baz
separately; then to do the containment query, it would look for rows containing
all three of these items. While GIN indexes can perform such an AND search
fairly efficiently, it will still be less specific and slower than the
equivalent jsonb_path_ops search, especially if there are a very large number of
rows containing any single one of the three index items.



==============
GIST (generalized search tree) : 

See also cstheoryGeneralizedSearchTree

Builds off work at Berkeley (Hellerstein)

combine B-tree, R-tree and user-defined index types

column must be tsvector or tsquery type

lossy - can produce false matches

each document represented by fixed-len signature

The signature is generated by hashing each word into a single bit in an 
n-bit string, with all these bits OR-ed together to produce an n-bit 
document signature. When two words hash to the same bit position there 
will be a false match. If all words in the query have matches (real 
or false) then the table row must be retrieved to see if the match 
is correct.

http://www.sai.msu.su/~megera/postgres/gist/

http://www.sai.msu.su/~megera/wiki/GiST_Algo




