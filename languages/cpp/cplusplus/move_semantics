
ref collapsing
T& & = T&
T&& & = T&
T& && = T&
T&& && = T&&

===

COmpiler generated move op and ctor if all members and base classes are movable - builtin types, STL and Boost containers

you should define copy ctor or destructor - otherwise compiler disables its implicit&

Slide 290 
user-defined move assign or ctor => no copy ops generated by compiler

interaction with "default" keyword or "delete", or "explicit"

beware of threads and move


========

lvalue which has been moved bcomes xvalue : a lvalue that can be treated as rvalue. (Myers slide 240)

exception obj can be move-constructed from lvalue throw operand (Myers)

rvalue refs identify objs that can be moved from (myers slide 242)

const rvalue is useless : const T&&  - bcos you cant move from it

===========
ret val opt
how move is implemented
move - nothrow swap - cascading
condition when move is invoked

stl example - diff betn 4.8 amd 4,6

canon example - const ref vs pass by value

lvalue = perm obj whose addr can be taken
rvalue = temp obj or literal = can be xvalue /prvalue
glvalue = can be lvalue or xvalue
xvalue = 
prvalue = 

Old way was to ret-by-ptr or ret-by-ref
In C++11, u can ret-by-value - compiler does ret-value optimization or invokes vector's move constructor.  Fallback is to use copy ctor

Generate asm code and show difference

Vector
http://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement

Where does STL provide "move" support

RVO : ret value optimization
NRVO : named ret value optimization

============

Why is std::move called a "cast" - it casts an "rvalue" to an "xvalue".  No obj are moved or copied

See /usr/include/c++/4.8/type_traits

String&& x = static_cast<String&&>
String&& x = std::move(y)

std::forward

std::is_reference
std::is_pointer
std::is_lvalue_reference
std::is_rvalue_reference
std::is_function
std::is_member_pointer

Rule of 3 becomes Rule of 5
http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29

===============

Definition of std::move

template<typename T>
inline typename std::remove_reference<T>::type&&
move(T&& t)
{
   return
      static_cast<typename std::remove_reference<T>::type&&>(t);
}


============

Definition of swap

template<typename T>
inline void swap(T& a, T& b)
{
   T tmp = std::move(a);
   a = std::move(b);
   b = std::move(tmp);
}

=================

Benchmark on move usage

std::forward

================


If overloading done on multiple param with rvalue and lvalue, which func will be chosen?
    void f(int&& param)
    void f(int& param)

Just define one ctor which takes everything by value

http://cpptruths.blogspot.in/2012/03/rvalue-references-in-constructor-when.html

. If you implement the assignment operator by taking the rhs parameter by value (which you already should do, to exploit any potential copy elision), you can get a move assignment operator for free simply by defining a move constructor. Then the one assignment operator will work for both move and copy assignment purposes, rather than needing two different assignment operators.

: Any named variable is an lvalue. So unless you use std:::move, compiler does not attempt a move. 

In non-template code, if all the parameter types provide an efficient move constructor, the proposed technique in the post is a safe bet. You see at least two exceptions. First, non-template code: So what's different in template code? Templates open up more possibilities, such as perfect forwarding, which depends on using pass-by-rvalue-reference as opposed to pass-by-value. Compiler will figure out the best way passing the parameter. However, there is a gotcha and its solution rather requires pretty deep knowledge of language mechanics. So much wizardry is packed in it that it is counter productive IMHO. Please see this for more detail: http://codesynthesis.com/~boris/blog/2012/03/14/rvalue-reference-pitfalls-update


==========

define constructor which takes args by value

    Class::Class("string a" instead of "const string &")
    {
    }

literals get passed to rvalue ctor

    Move ctor Class(Class&&)
    Move op : Class& operator=(Class&&)

define return value to be 
    Class&& func()
    {
    }

==========

TODO

http://codesynthesis.com/~boris/blog/2012/03/14/rvalue-reference-pitfalls-update

http://mbevin.wordpress.com/2012/11/20/move-semantics/

http://en.cppreference.com/w/cpp/language/move_constructor

http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers

http://stackoverflow.com/questions/9671749/whats-the-difference-between-stdmove-and-stdforward

http://www.codeproject.com/Articles/397492/Move-Semantics-and-Perfect-Forwarding-in-Cplusplus

http://stackoverflow.com/questions/3106110/what-are-move-semantics

http://thbecker.net/articles/rvalue_references/section_01.html

=================

transfer ownership of temporary objects instead of copying & destroying them

rvalue  - whose mem loc u cant take
std::move - just a static cast to rvalue reference
string && name = getName() which returns a const

move constructor ---         Array(Array&& other)
move assignment operator --- X& X::operator=(X&& rhs)

template<class T> 
void swap(T& a, T& b) 
{ 
  T tmp(std::move(a));
  a = std::move(b); 
  b = std::move(tmp);
} 


==============


1) What exactly is std::move ?
Where is it defined - move.h (also defined swap and forward)

std::remove_reference - trace the definition

How to cast lvalue to rvalue
rvalue = static_cast<T&&> (lvalue)
or use
std::move(lvalue)

====================
Constructors with multiple args - Sumant's post
====================

http://stackoverflow.com/questions/12922138/is-the-copy-and-swap-idiom-still-useful-in-c11

copy and swap idiom : reuse the ctor to define the assignment op
swap calls move, not other way round


f operator = is defined as

MyClass2 & operator=(MyClass2 rhs)

Then whenever rhs is a r-value, the move constructor will be called. However, this means that when using:

MyClass2(MyClass2 && rhs)
{
    //*this = std::move(rhs);
}

Notice you end up with a recursive call to the move constructor, as operator= calls the move constructor...

====================

swap and move 
do we still write swap for our classes ?
template <class T>
void swap(T& a, T&b) noexcept
{
}

std::swap calls a move ctor and 2 move assignments

http://stackoverflow.com/questions/8617305/is-specializing-stdswap-deprecated-now-that-we-have-move-semantics

http://stackoverflow.com/questions/6416385/move-semantics-custom-swap-function-obsolete
=============

2) How STL uses std::move (differences from g++ 4.6)
Each class has added move ctor, 

Overloaded on "const T&" and "T&&" - first called on lvalue, second on rvalue

Containers have _M_impl (pointer to impl)
$ grep _M_impl\; *.h 

Others have _M_t, _M_ptr
Containers have push_back(rvalue)
{
    std::move(rvalue)
}

List::splice is redefined

defined in every class

#if __cplus >= 201103L
    _List_base(_List_base&& __x)
    : _M_impl (std::move(__x._M_get_Node_allocator()))
{
}

==============
